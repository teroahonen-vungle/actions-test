name: Apiserver deploy to DEV
on:
  push:
    tags:
      - 'dev'
  # Allows you to run this workflow manually from the Actions tab
  workflow_dispatch:
env:
  DEPLOYMENT: apiserver
  OC_PROJECT: saas-dev
  QUAY_REGISTRY: quay.io/gamerefinery
  REPO: apiserver-service
  IMAGE_TAG: dev
jobs:
  compile:
    name: Compile
    runs-on: ubuntu-latest
    outputs:
      artifactname: ${{ steps.get-artifactname.outputs.artifactname }}
      commit_sha: ${{ steps.commit-data.outputs.short_sha }}
    env:
      TARGET_DIR: target/
      MVN_REPO_DIR: ~/.m2/repository
    steps:
    - uses: actions/checkout@v2

    # If none of these files has changed, we assume that the contents of .m2/repository can be fetched from the cache.
    - name: Hash Maven files
      run: |
        echo "MVN_HASH=${{ hashFiles('pom.xml', '.mvn/**/*', 'mvnw*') }}" >> $GITHUB_ENV
    # Download the m2 repository from the cache to speed up the build.
    - name: Check for Maven cache
      id: check-mvn-cache
      uses: actions/cache@v2
      with:
        path: ${{ env.MVN_REPO_DIR }}
        key: ${{ env.MVN_HASH }}

    - name: Setup Java
      uses: actions/setup-java@v1
      with:
        java-version: 11
        server-id: gamerefinery
        server-username: MAVEN_USERNAME
        server-password: MAVEN_PASSWORD
        
    - run: java -version

    - run: mvn -ntp -B package
      env:
        MAVEN_USERNAME: ${{ secrets.ARTIFACTORY_USER }}
        MAVEN_PASSWORD: ${{ secrets.ARTIFACTORY_PASSWORD }}
    # If there was no cache hit above, store the output into the cache now.
    - name: Save Maven repo into cache
      if: ${{ steps.check-mvn-cache.outputs.cache-hit }} != 'true'
      uses: actions/cache@v2
      with:
        path: ${{ env.MVN_REPO_DIR }}
        key: ${{ env.MVN_HASH }}

    # Store the output jar into the env for reuse below.
    # It will contain, eg. "spring-petclinic-2.3.0.BUILD-SNAPSHOT.jar"
    - name: Get artifact name
      id: get-artifactname
      run: |
        export ARTIFACT_NAME="$(basename $(ls target/*.war))"
        echo "$DEPLOYMENT artifact is $ARTIFACT_NAME"
        echo "::set-output name=artifactname::$ARTIFACT_NAME"
        echo "ARTIFACT_NAME=$ARTIFACT_NAME" >> $GITHUB_ENV
    # Upload the jar for future jobs to use.
    - uses: actions/upload-artifact@v2
      with:
        name: ${{ env.ARTIFACT_NAME }}
        path: ${{ env.TARGET_DIR }}/${{ env.ARTIFACT_NAME }}
        if-no-files-found: error
    - uses: actions/upload-artifact@v2
      with:
        name: Dockerfile
        path: Dockerfile
        if-no-files-found: error
    # Use the commit short-sha as the suffix of the app_name
    - name: Get commit short-sha
      id: commit-data
      uses: redhat-actions/common/commit-data@v1

  build-push-image:
    name: Build and Push to Quay
    runs-on: ubuntu-latest
    needs: compile
    outputs:
      registry-path: ${{ steps.push-to-quay.outputs.registry-path }}
    env:
      ARTIFACT_NAME: ${{ needs.compile.outputs.artifactname }}
      IMAGE_TAGS: latest staging ${{ needs.compile.outputs.commit_sha }}
    steps:
      # Download the jar artifact from the compile step
      - uses: actions/download-artifact@v2
        with:
          name: ${{ env.ARTIFACT_NAME }}
      - uses: actions/download-artifact@v2
        with:
          name: Dockerfile
      - name: Display structure of downloaded files
        run: ls -R
      - name: Login to Quay
        uses: docker/login-action@v1 
        with:
          logout: false  
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_PASSWORD }}
          registry: quay.io
      # Use buildah to build the application image with the jar inside.
      - name: Build and push
        uses: docker/build-push-action@v2
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          build-args: |
            WAR_FILE=${{ env.ARTIFACT_NAME }}
          tags: |
             ${{env.QUAY_REGISTRY}}/${{env.REPO}}:${{env.IMAGE_TAG}}
             ${{env.QUAY_REGISTRY}}/${{env.REPO}}:${{ needs.compile.outputs.commit_sha }}
  deploy:
    name: Deploy to OpenShift
    runs-on: ubuntu-latest
    needs: build-push-image
    steps:
      - name: Login to OpenShift
        run: oc login ${{ secrets.OC_API_ENDPOINT_EU }} --token=${{ secrets.OC_TOKEN_DEV_EU }}
      - name: Rollout deployment
        run: oc rollout latest ${{env.DEPLOYMENT}} -n ${{env.OC_PROJECT}}
